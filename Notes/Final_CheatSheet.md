## Built-in Functions

`round()` 函数在Python中对浮点数进行四舍五入时，遵循了称为“银行家舍入”或“偶数舍入”的规则。

当一个数正好位于两个整数之间时（例如 2.5，位于 2 和 3 之间），这种规则指定应舍入到最近的偶数。这种舍入方式的好处是，在多次舍入运算时可以避免总体的累积偏差。



## 逻辑运算

- 逻辑运算符（如 `or`）是短路求值的。这意味着如果左边的操作数已经确定了整个表达式的值，那么右边的操作数就不会被评估。
  - 例如 `1>1+1 or 3>7-6 or 6>7/0` ，第二个操作数为True，那么python不会计算之后的操作数，所以不会识别到ZeroDivisionError：
- 逻辑运算符中，`and`的运算顺序要优于`or`

- `11&4`: 这个表达式使用了按位与运算符 `&` 来计算两个整数 11 和 4 的二进制按位与结果。 `1011 & 0100 = 0000 = 0`
- 在多重比较时, 会从左到右进行评估
  - 例如`False == True == False`，其实是`False == True and True == False`



## List

复杂的list表达式例子：

1. `[ 5, [3], [2, 3] ] [ [2,[1]] [1] ] [ :[1,2][1] ]`, 即三个部分: `[5, [3], [2, 3]]`, `[[2,[1]] [1]]`, `[:[1,2][1]]`
   - 第二个部分: `[[2,[1]] [1]]`，即是`[2,[1]]`的第二个元素，所以返回`[[1]]`
   - 第三个部分: `[:[1,2][1]]`, 即是`[:2]`
   - 然而`[5, [3], [2, 3]][[1]]`不合法，所以此表达式会抛出错误
2. `[ 5, [3], [2, 3] ] [ [2,[1]] [0] ] [ :[1,2][1] ]`
   - 第二个部分: `[[2,[1]] [0]]`，即是`[2,[1]]`的第一个元素，所以返回`[2]`
   - 其余和第一个例子相同
   - `[5, [3], [2, 3]][2]`为`[2,3]`
   - `[2,3][:2]`为`[2]`，此为答案



## Dictionary

- 不能在迭代过程中修改正在迭代的容器的大小或结构，但可以修改字典中现有键的值。在您给出的代码中，您试图在迭代字典`a`的过程中删除其键。这会导致一个运行时错误。
- 如果在插入键值对时，键已经存在；那么此键对应的值会被覆写为新的值

- `set` (e.g., `d[k] = v`)：设置一个键值对 - O*(1)
- `get` (e.g., `d[k]`)：获取一个键的值 - O(1)
- `del`：删除一个键值对 - O(1)
- `in`：检查键是否存在 - *O*(1)
- `len`：返回键值对数量 - *O*(1)
- `keys`：返回所有键 - *O*(*n*)
- `values`：返回所有值 - *O*(*n*)
- `items`：返回所有键值对 - *O*(*n*)



## `map()` & `filter()`

- map和filter函数都返回一个可迭代的对象，只能读取一次



## Lambda Function

- Lambda函数的输入如果在for loop中，那么他只会捕获for loop的最终值
  - 例如`lambda x: i + x for i in range(3)`，此处的i只会是3
- 



## OOP

- 当一个类使用了多重继承时，那么`__init__`函数会调用在括号内的第一个父类的`__init__`函数
  - 例如`class Paladin(Fighter, Cleric)`, 如果`Paladin`类中要打印一个`self`对象的值，那么这个值是继承自`Fighter`父类
- 